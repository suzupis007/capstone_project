# Step 2: Perform Box-Cox transformation on the response variable
response_boxcox <- MASS::boxcox(slm, plotit = FALSE)
optimal_lambda <- response_boxcox$x[which.max(response_boxcox$y)]
# Step 3: Transform the response variable using the optimal lambda
transformed_response <- ifelse(optimal_lambda == 0, log(data[[response_var]]), data[[response_var]]^optimal_lambda)
# Step 4: Fit a new linear model with the transformed response variable
transformed_formula <- as.formula(paste("transformed_response ~", predictor))
slm_transformed <- lm(transformed_formula, data = data)
# Extract R-squared and Adjusted R-squared values
original_r_squared <- summary(slm)$r.squared
original_adj_r_squared <- summary(slm)$adj.r.squared
transformed_r_squared <- summary(slm_transformed)$r.squared
transformed_adj_r_squared <- summary(slm_transformed)$adj.r.squared
# Store the results in the data frame
results <- rbind(results, data.frame(
Predictor = predictor,
Optimal_Lambda = optimal_lambda,
Original_R_squared = original_r_squared,
Original_Adj_R_squared = original_adj_r_squared,
Transformed_R_squared = transformed_r_squared,
Transformed_Adj_R_squared = transformed_adj_r_squared
))
}
return(results)
}
# Example usage:
response_var <- "pct_poor_to_fair_health"
predictors <- setdiff(names(temp_qol_data), response_var)
qol_train<- qol_train %>%
rename("pct_poor_to_fair_health" = "response")
# Function to perform Box-Cox transformation on each feature
boxcox_transform <- function(response_var, predictors, data) {
results <- data.frame(
Predictor = character(),
Optimal_Lambda = numeric(),
Original_R_squared = numeric(),
Original_Adj_R_squared = numeric(),
Transformed_R_squared = numeric(),
Transformed_Adj_R_squared = numeric(),
stringsAsFactors = FALSE
)
for (predictor in predictors) {
# Step 1: Fit a linear model with the response and the unique feature
formula <- as.formula(paste(response_var, "~", predictor))
slm <- lm(formula, data = data)
# Step 2: Perform Box-Cox transformation on the response variable
response_boxcox <- MASS::boxcox(slm, plotit = FALSE)
optimal_lambda <- response_boxcox$x[which.max(response_boxcox$y)]
# Step 3: Transform the response variable using the optimal lambda
transformed_response <- ifelse(optimal_lambda == 0, log(data[[response_var]]), data[[response_var]]^optimal_lambda)
# Step 4: Fit a new linear model with the transformed response variable
transformed_formula <- as.formula(paste("transformed_response ~", predictor))
slm_transformed <- lm(transformed_formula, data = data)
# Extract R-squared and Adjusted R-squared values
original_r_squared <- summary(slm)$r.squared
original_adj_r_squared <- summary(slm)$adj.r.squared
transformed_r_squared <- summary(slm_transformed)$r.squared
transformed_adj_r_squared <- summary(slm_transformed)$adj.r.squared
# Store the results in the data frame
results <- rbind(results, data.frame(
Predictor = predictor,
Optimal_Lambda = optimal_lambda,
Original_R_squared = original_r_squared,
Original_Adj_R_squared = original_adj_r_squared,
Transformed_R_squared = transformed_r_squared,
Transformed_Adj_R_squared = transformed_adj_r_squared
))
}
return(results)
}
# Example usage:
response_var <- "pct_poor_to_fair_health"
predictors <- setdiff(names(qol_train), response_var)
results <- boxcox_transform(response_var, predictors, qol_train)
library(MASS)
library(dplyr)
# Function to perform Box-Cox transformation on each feature
boxcox_transform <- function(response_var, predictors, data) {
results <- data.frame(
Predictor = character(),
Optimal_Lambda = numeric(),
Original_R_squared = numeric(),
Original_Adj_R_squared = numeric(),
Transformed_R_squared = numeric(),
Transformed_Adj_R_squared = numeric(),
stringsAsFactors = FALSE
)
for (predictor in predictors) {
# Step 1: Fit a linear model with the response and the unique feature
formula <- as.formula(paste(response_var, "~", predictor))
slm <- lm(formula, data = data)
# Debug: Print summary of the initial linear model
print(summary(slm))
# Step 2: Perform Box-Cox transformation on the response variable
response_boxcox <- MASS::boxcox(slm, plotit = FALSE)
optimal_lambda <- response_boxcox$x[which.max(response_boxcox$y)]
# Debug: Print the optimal lambda value
print(paste("Predictor:", predictor, "Optimal Lambda:", optimal_lambda))
# Step 3: Transform the response variable using the optimal lambda
transformed_response <- ifelse(optimal_lambda == 0, log(data[[response_var]]), data[[response_var]]^optimal_lambda)
# Debug: Print the transformed response variable
print(head(transformed_response))
# Step 4: Fit a new linear model with the transformed response variable
transformed_formula <- as.formula(paste("transformed_response ~", predictor))
slm_transformed <- lm(transformed_formula, data = data)
# Extract R-squared and Adjusted R-squared values
original_r_squared <- summary(slm)$r.squared
original_adj_r_squared <- summary(slm)$adj.r.squared
transformed_r_squared <- summary(slm_transformed)$r.squared
transformed_adj_r_squared <- summary(slm_transformed)$adj.r.squared
# Debug: Print summary of the transformed linear model
print(summary(slm_transformed))
# Store the results in the data frame
results <- rbind(results, data.frame(
Predictor = predictor,
Optimal_Lambda = optimal_lambda,
Original_R_squared = original_r_squared,
Original_Adj_R_squared = original_adj_r_squared,
Transformed_R_squared = transformed_r_squared,
Transformed_Adj_R_squared = transformed_adj_r_squared
))
}
return(results)
}
# Example usage:
response_var <- "pct_poor_to_fair_health"
predictors <- setdiff(names(qol_train), response_var)
results <- boxcox_transform(response_var, predictors, qol_train)
library(MASS)
library(dplyr)
# Function to perform Box-Cox transformation on each feature
boxcox_transform <- function(response_var, predictors, data) {
results <- data.frame(
Predictor = character(),
Optimal_Lambda = numeric(),
Original_R_squared = numeric(),
Original_Adj_R_squared = numeric(),
Transformed_R_squared = numeric(),
Transformed_Adj_R_squared = numeric(),
stringsAsFactors = FALSE
)
for (predictor in predictors) {
# Step 1: Fit a linear model with the response and the unique feature
formula <- as.formula(paste(response_var, "~", predictor))
slm <- lm(formula, data = data)
# Debug: Print summary of the initial linear model
print(summary(slm))
# Step 2: Perform Box-Cox transformation on the response variable
response_boxcox <- MASS::boxcox(slm, plotit = FALSE)
optimal_lambda <- response_boxcox$x[which.max(response_boxcox$y)]
# Debug: Print the optimal lambda value
print(paste("Predictor:", predictor, "Optimal Lambda:", optimal_lambda))
# Step 3: Transform the response variable using the optimal lambda
transformed_response <- if (optimal_lambda == 0) {
log(data[[response_var]])
} else {
data[[response_var]]^optimal_lambda
}
# Debug: Print the transformed response variable
print(head(transformed_response))
# Add the transformed response to the data frame
data$transformed_response <- transformed_response
# Step 4: Fit a new linear model with the transformed response variable
transformed_formula <- as.formula(paste("transformed_response ~", predictor))
slm_transformed <- lm(transformed_formula, data = data)
# Extract R-squared and Adjusted R-squared values
original_r_squared <- summary(slm)$r.squared
original_adj_r_squared <- summary(slm)$adj.r.squared
transformed_r_squared <- summary(slm_transformed)$r.squared
transformed_adj_r_squared <- summary(slm_transformed)$adj.r.squared
# Debug: Print summary of the transformed linear model
print(summary(slm_transformed))
# Store the results in the data frame
results <- rbind(results, data.frame(
Predictor = predictor,
Optimal_Lambda = optimal_lambda,
Original_R_squared = original_r_squared,
Original_Adj_R_squared = original_adj_r_squared,
Transformed_R_squared = transformed_r_squared,
Transformed_Adj_R_squared = transformed_adj_r_squared
))
}
return(results)
}
# Example usage:
response_var <- "pct_poor_to_fair_health"
predictors <- setdiff(names(qol_train), response_var)
results <- boxcox_transform(response_var, predictors, qol_train)
# Function to perform Box-Cox transformation on each feature
boxcox_transform <- function(response_var, predictors, data) {
results <- data.frame(
Predictor = character(),
Optimal_Lambda = numeric(),
Original_R_squared = numeric(),
Original_Adj_R_squared = numeric(),
Transformed_R_squared = numeric(),
Transformed_Adj_R_squared = numeric(),
stringsAsFactors = FALSE
)
for (predictor in predictors) {
# Step 1: Fit a linear model with the response and the unique feature
lm_formula <- as.formula(paste(response_var, "~", predictor))
slm <- lm(lm_formula, data = data)
# Debug: Print summary of the initial linear model
print(summary(slm))
# Step 2: Perform Box-Cox transformation on the response variable
response_boxcox <- MASS::boxcox(slm, plotit = FALSE)
optimal_lambda <- response_boxcox$x[which.max(response_boxcox$y)]
# Debug: Print the optimal lambda value
print(paste("Predictor:", predictor, "Optimal Lambda:", optimal_lambda))
# Step 3: Transform the response variable using the optimal lambda
transformed_response <- if (optimal_lambda == 0) {
log(data[[response_var]])
} else {
data[[response_var]]^optimal_lambda
}
# Debug: Print the transformed response variable
print(head(transformed_response))
# Add the transformed response to the data frame
data$transformed_response <- transformed_response
# Step 4: Fit a new linear model with the transformed response variable
transformed_lm_formula <- as.formula(paste("transformed_response ~", predictor))
slm_transformed <- lm(transformed_lm_formula, data = data)
# Extract R-squared and Adjusted R-squared values
original_r_squared <- summary(slm)$r.squared
original_adj_r_squared <- summary(slm)$adj.r.squared
transformed_r_squared <- summary(slm_transformed)$r.squared
transformed_adj_r_squared <- summary(slm_transformed)$adj.r.squared
# Debug: Print summary of the transformed linear model
print(summary(slm_transformed))
# Store the results in the data frame
results <- rbind(results, data.frame(
Predictor = predictor,
Optimal_Lambda = optimal_lambda,
Original_R_squared = original_r_squared,
Original_Adj_R_squared = original_adj_r_squared,
Transformed_R_squared = transformed_r_squared,
Transformed_Adj_R_squared = transformed_adj_r_squared
))
}
return(results)
}
# Example usage:
response_var <- "pct_poor_to_fair_health"
predictors <- setdiff(names(qol_train), response_var)
results <- boxcox_transform(response_var, predictors, qol_train)
library(MASS)
library(dplyr)
# Function to perform Box-Cox transformation on each feature
boxcox_transform <- function(response_var, predictors, data) {
results <- data.frame(
Predictor = character(),
Optimal_Lambda = numeric(),
Original_R_squared = numeric(),
Original_Adj_R_squared = numeric(),
Transformed_R_squared = numeric(),
Transformed_Adj_R_squared = numeric(),
stringsAsFactors = FALSE
)
for (predictor in predictors) {
# Step 1: Fit a linear model with the response and the unique feature
lm_formula <- as.formula(paste(response_var, "~", predictor))
slm <- lm(lm_formula, data = data)
# Step 2: Perform Box-Cox transformation on the response variable
response_boxcox <- MASS::boxcox(slm, plotit = FALSE)
optimal_lambda <- response_boxcox$x[which.max(response_boxcox$y)]
# Step 3: Transform the response variable using the optimal lambda
transformed_response <- ifelse(optimal_lambda == 0, log(data[[response_var]]), data[[response_var]]^optimal_lambda)
# Step 4: Fit a new linear model with the transformed response variable
transformed_formula <- as.formula(paste("transformed_response ~", predictor))
data$transformed_response <- transformed_response  # Add transformed response to the data
slm_transformed <- lm(transformed_formula, data = data)
# Extract R-squared and Adjusted R-squared values
original_r_squared <- summary(slm)$r.squared
original_adj_r_squared <- summary(slm)$adj.r.squared
transformed_r_squared <- summary(slm_transformed)$r.squared
transformed_adj_r_squared <- summary(slm_transformed)$adj.r.squared
# Store the results in the data frame
results <- rbind(results, data.frame(
Predictor = predictor,
Optimal_Lambda = optimal_lambda,
Original_R_squared = original_r_squared,
Original_Adj_R_squared = original_adj_r_squared,
Transformed_R_squared = transformed_r_squared,
Transformed_Adj_R_squared = transformed_adj_r_squared
))
}
return(results)
}
# Example usage:
response_var <- "pct_poor_to_fair_health"
predictors <- setdiff(names(qol_train), response_var)
results <- boxcox_transform(response_var, predictors, qol_train)
library(MASS)
library(dplyr)
# Function to perform Box-Cox transformation on each feature
boxcox_transform <- function(response_var, predictors, data) {
transform_output <- data.frame(
Predictor = character(),
Optimal_Lambda = numeric(),
Original_R_squared = numeric(),
Original_Adj_R_squared = numeric(),
Transformed_R_squared = numeric(),
Transformed_Adj_R_squared = numeric(),
stringsAsFactors = FALSE
)
for (predictor in predictors) {
# Step 1: Fit a linear model with the response and the unique feature
lm_formula <- as.formula(paste(response_var, "~", predictor))
slm <- lm(lm_formula, data = data)
# Step 2: Perform Box-Cox transformation on the response variable
response_boxcox <- MASS::boxcox(slm, plotit = FALSE)
optimal_lambda <- response_boxcox$x[which.max(response_boxcox$y)]
# Step 3: Transform the response variable using the optimal lambda
transformed_response <- ifelse(optimal_lambda == 0, log(data[[response_var]]), data[[response_var]]^optimal_lambda)
# Step 4: Fit a new linear model with the transformed response variable
transformed_formula <- as.formula(paste("transformed_response ~", predictor))
data$transformed_response <- transformed_response  # Add transformed response to the data
slm_transformed <- lm(transformed_formula, data = data)
# Extract R-squared and Adjusted R-squared values
original_r_squared <- summary(slm)$r.squared
original_adj_r_squared <- summary(slm)$adj.r.squared
transformed_r_squared <- summary(slm_transformed)$r.squared
transformed_adj_r_squared <- summary(slm_transformed)$adj.r.squared
# Store the results in the data frame
results <- rbind(boxcox_transform, data.frame(
Predictor = predictor,
Optimal_Lambda = optimal_lambda,
Original_R_squared = original_r_squared,
Original_Adj_R_squared = original_adj_r_squared,
Transformed_R_squared = transformed_r_squared,
Transformed_Adj_R_squared = transformed_adj_r_squared
))
}
return(results)
}
# Example usage:
response_var <- "pct_poor_to_fair_health"
predictors <- setdiff(names(qol_train), response_var)
results <- boxcox_transform(response_var, predictors, qol_train)
qol_train<- qol_train %>%
rename("response"="pct_poor_to_fair_health")
qol_test<- qol_test %>%
rename("response"="pct_poor_to_fair_health")
lm_ <- lm(weighted_population ~ pct_poor_to_fair_health,
qol_data)
lm_ <- lm(weighted_population ~ response,
qol_data)
summary(linear_fit)
lm_weighted_pop <- lm(weighted_population ~ response,
qol_data)
summary(lm_weighted_pop)
par(mfrow = c(2,2))
plot(linear_fit)
lm_weighted_pop <- lm(weighted_population ~ response,
qol_data)
summary(lm_weighted_pop)
par(mfrow = c(2,2))
plot(lm_weighted_pop)
par(mfrow = c(1,1))
box_cox_weighted_pop <- MASS::boxcox(object = lm_weighted_pop,
from = -0.1,
to = 0.1)
summary(box_cox)
lm_weighted_pop <- lm(weighted_population ~ response,
qol_data)
summary(lm_weighted_pop)
par(mfrow = c(2,2))
plot(lm_weighted_pop)
par(mfrow = c(1,1))
box_cox_weighted_pop <- MASS::boxcox(object = lm_weighted_pop,
from = -0.1,
to = 0.1)
summary(box_cox_weighted_pop)
print(box_cox_weighted_pop$y)
which.min(box_cox_weighted_pop$y)
lm_weighted_pop <- lm(weighted_population ~ response,
qol_data)
summary(lm_weighted_pop)
par(mfrow = c(2,2))
plot(lm_weighted_pop)
par(mfrow = c(1,1))
box_cox_weighted_pop <- MASS::boxcox(object = lm_weighted_pop,
from = -0.1,
to = 0.1)
summary(box_cox_weighted_pop)
print(box_cox_weighted_pop$y)
which.max(box_cox_weighted_pop$y[box_cox_weighted_pop])
lm_weighted_pop <- lm(weighted_population ~ response,
qol_data)
summary(lm_weighted_pop)
par(mfrow = c(2,2))
plot(lm_weighted_pop)
par(mfrow = c(1,1))
box_cox_weighted_pop <- MASS::boxcox(object = lm_weighted_pop,
from = -0.1,
to = 0.1)
summary(box_cox_weighted_pop)
print(box_cox_weighted_pop$y)
which.max(box_cox_weighted_pop$y[box_cox_weighted_pop$x])
lm_weighted_pop <- lm(weighted_population ~ response,
qol_data)
summary(lm_weighted_pop)
par(mfrow = c(2,2))
plot(lm_weighted_pop)
par(mfrow = c(1,1))
box_cox_weighted_pop <- MASS::boxcox(object = lm_weighted_pop,
from = -0.1,
to = 0.1)
summary(box_cox_weighted_pop)
print(box_cox_weighted_pop$y)
(box_cox_weighted_pop$xwhich.max([box_cox_weighted_pop$x]))
lm_weighted_pop <- lm(weighted_population ~ response,
qol_data)
summary(lm_weighted_pop)
par(mfrow = c(2,2))
plot(lm_weighted_pop)
par(mfrow = c(1,1))
box_cox_weighted_pop <- MASS::boxcox(object = lm_weighted_pop,
from = -0.1,
to = 0.1)
summary(box_cox_weighted_pop)
print(box_cox_weighted_pop$y)
box_cox_weighted_pop$x[which.max(box_cox_weighted_pop$x)]
lm_weighted_pop <- lm(weighted_population ~ response,
qol_data)
summary(lm_weighted_pop)
par(mfrow = c(2,2))
plot(lm_weighted_pop)
par(mfrow = c(1,1))
box_cox_weighted_pop <- MASS::boxcox(object = lm_weighted_pop,
from = -0.1,
to = 0.1)
summary(box_cox_weighted_pop)
print(box_cox_weighted_pop$y)
box_cox_weighted_pop$x[which.max(box_cox_weighted_pop$y)]
knitr::opts_chunk$set(echo = TRUE)
# Fit the initial linear model
lf_weighted_pop <- lm(
weighted_population ~ pct_poor_to_fair_health,
data = qol_data
)
# results data frame
transform_output <- data.frame(
Predictor = character(),
Optimal_Lambda = numeric(),
Original_R_squared = numeric(),
Original_Adj_R_squared = numeric(),
Transformed_R_squared = numeric(),
Transformed_Adj_R_squared = numeric(),
stringsAsFactors = FALSE
)
# results data frame
transform_output <- data.frame(
Predictor = character(),
Optimal_Lambda = numeric(),
Original_R_squared = numeric(),
Original_Adj_R_squared = numeric(),
Transformed_R_squared = numeric(),
Transformed_Adj_R_squared = numeric(),
stringsAsFactors = FALSE
)
# Fit the initial linear model
lm_initial <- lm(
pct_poor_to_fair_health ~ weighted_population,
qol_data)
# Fit the initial linear model
lm_initial <- lm(
response ~ weighted_population,
qol_data)
summary(lm_initial)
# Plot diagnostic plots for the initial model
par(mfrow = c(2, 2))
plot(lm_initial)
par(mfrow = c(1, 1))
# Perform Box-Cox transformation on the predictor variable (treated as response)
box_cox_result <- MASS::boxcox(lm
(weighted_population ~ 1,
qol_data
),
plotit = TRUE
)
# Identify the optimal lambda
optimal_lambda <- box_cox_result$x[which.max(box_cox_result$y)]
print(optimal_lambda)
# Transform the predictor variable using the optimal lambda
transformed_predictor <- ifelse(
optimal_lambda == 0,
log(qol_data$weighted_population),
qol_data$weighted_population^optimal_lambda)
# Fit a new linear model with the transformed predictor variable
transformed_lm <- lm(pct_poor_to_fair_health ~ transformed_predictor, qol_data)
# Fit the initial linear model
lm_initial <- lm(
response ~ weighted_population,
qol_data)
summary(lm_initial)
# Plot diagnostic plots for the initial model
par(mfrow = c(2, 2))
plot(lm_initial)
par(mfrow = c(1, 1))
# Perform Box-Cox transformation on the predictor variable (treated as response)
box_cox_result <- MASS::boxcox(lm
(weighted_population ~ 1,
qol_data
),
plotit = TRUE
)
# Identify the optimal lambda
optimal_lambda <- box_cox_result$x[which.max(box_cox_result$y)]
print(optimal_lambda)
# Transform the predictor variable using the optimal lambda
